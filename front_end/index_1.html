<!DOCTYPE HTML>
<!-- http://blog.sethladd.com/2011/09/box2d-and-joints-for-javascript.html -->
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9">
    <title>Cocos2D-JS Simple Game Demo | raywenderlich.com</title>
    <script src="box2d.js"></script>

    <script>
    
        var canvas, context, screenW, screenH, world, drawDebug;

        // bunch of variables required for various box2d objects
        var b2Vec2 = Box2D.Common.Math.b2Vec2
        ,b2AABB = Box2D.Collision.b2AABB
        ,b2BodyDef = Box2D.Dynamics.b2BodyDef
        ,b2Body = Box2D.Dynamics.b2Body
        ,b2FixtureDef = Box2D.Dynamics.b2FixtureDef
        ,b2Fixture = Box2D.Dynamics.b2Fixture
        ,b2World = Box2D.Dynamics.b2World
        ,b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
        ,b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
        ,b2DebugDraw = Box2D.Dynamics.b2DebugDraw
        ,b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef
        ;


        var MAX_STEER_ANGLE = Math.PI/3;
        var STEER_SPEED = 1.5;
        var SIDEWAYS_FRICTION_FORCE = 10;
        var HORSEPOWERS = 40
        var CAR_STARTING_POS = new b2Vec2(10,10);
 
        var leftRearWheelPosition = new b2Vec2(-1.5,1.90);
        var rightRearWheelPosition = new b2Vec2(1.5,1.9);
        var leftFrontWheelPosition = new b2Vec2(-1.5,-1.9);
        var rightFrontWheelPosition = new b2Vec2(1.5,-1.9);

        var engineSpeed =0;
        var steeringAngle = 0

        function init()
        {
         // Defining and initializing our canvas elements
         window.onkeydown = keydown;
         canvas = document.getElementById("canvas");
         context = canvas.getContext("2d");
         screenW = canvas.width, screenH = canvas.height;

         debugDraw = true;

          // Define the world
          world = new b2World(
                       new b2Vec2(0, 0)    //gravity of 10 in downward y direction
                    ,  true                 //allows objects to sleep if they are in equilibrium, indicated by change of color from Red to Grey in debugDraw mode
                 );

          // Scale is required to convert our pixel space into meters. A scale of 10 means 10px = 1m
          var scale = 20.0;


          // define our body
          var bodyDef = new b2BodyDef();
          bodyDef.linearDamping = 1;
          bodyDef.angularDamping = 1;
          bodyDef.position = CAR_STARTING_POS.Copy()  

       
          var leftWheelDef = new b2BodyDef();
          leftWheelDef.position = CAR_STARTING_POS.Copy();
          leftWheelDef.position.Add(leftFrontWheelPosition);
       

          var rightWheelDef = new b2BodyDef();
          rightWheelDef.position = CAR_STARTING_POS.Copy();
          rightWheelDef.position.Add(rightFrontWheelPosition);
       
          var leftRearWheelDef = new b2BodyDef();
          leftRearWheelDef.position = CAR_STARTING_POS.Copy();
          leftRearWheelDef.position.Add(leftRearWheelPosition);
       
          var rightRearWheelDef = new b2BodyDef();
          rightRearWheelDef.position = CAR_STARTING_POS.Copy();
          rightRearWheelDef.position.Add(rightRearWheelPosition);
          var rightRearWheel = world.CreateBody(rightRearWheelDef);
  
          // Body shape  
          var fixDef2 = new b2FixtureDef;
          fixDef2.density = 1;
          fixDef2.shape = new b2PolygonShape;
          fixDef2.shape.SetAsBox(1.5, 2.5);
          bodyDef.type = b2Body.b2_dynamicBody;

          var body = world.CreateBody(bodyDef).CreateFixture(fixDef2);
          

          //Right Wheel shape
          
          fixDef2.shape = new b2PolygonShape;
          fixDef2.shape.SetAsBox(0.2,0.5);
          fixDef2.density = 1;
          rightWheelDef.type = b2Body.b2_dynamicBody;
          var rightWheel = world.CreateBody(rightWheelDef).CreateFixture(fixDef2);


          //Left Wheel shape
          fixDef2.shape =  new b2PolygonShape;
          fixDef2.shape.SetAsBox(0.2,0.5);
          fixDef2.density = 1;
          leftWheelDef.type = b2Body.b2_dynamicBody;
          var leftWheel = world.CreateBody(leftWheelDef).CreateFixture(fixDef2);

          
          //Right Wheel shape
          fixDef2.shape = new b2PolygonShape;
          fixDef2.shape.SetAsBox(0.2,0.5);
          fixDef2.density = 1;
          leftRearWheelDef.type = b2Body.b2_dynamicBody;
          var leftRearWheel = world.CreateBody(leftRearWheelDef).CreateFixture(fixDef2);
          
          //Right Wheel shape
          fixDef2.shape = new b2PolygonShape;
          fixDef2.shape.SetAsBox(0.2,0.5);
          fixDef2.density = 1;
          rightRearWheelDef.type = b2Body.b2_dynamicBody;

          var rightRearWheel = world.CreateBody(rightRearWheelDef).CreateFixture(fixDef2);
          
          
          var leftJointDef = new b2RevoluteJointDef();
          leftJointDef.Initialize(body, leftWheel, leftWheel.GetBody().GetWorldCenter());
          leftJointDef.enableMotor = true;
          leftJointDef.maxMotorTorque = 100;
          

             // Define the Ground
             // Basic properties of ground
             var fixDef = new b2FixtureDef;
             fixDef.density = 2.0;
             fixDef.friction = 0.9;
             fixDef.restitution = 0.8;

             // Ground is nothing but just a static rectangular body with its center at screenW/2 and screenH
             var bodyDef = new b2BodyDef;
             bodyDef.type = b2Body.b2_staticBody;
             bodyDef.position.x = screenW/2/scale;
             // We use screenH for y coordinate as the ground has to be at the bottom of our screen
             bodyDef.position.y = screenH/scale;

             // here we define ground as a rectangular box of width = screenW and height = 10 (just some small number to make a thin strip)
             fixDef.shape = new b2PolygonShape;
             fixDef.shape.SetAsBox(screenW/scale, 10/scale);

             // And finally add our ground object to our world
             world.CreateBody(bodyDef).CreateFixture(fixDef);

             // Left Edge - Similar to ground, we define the left edge of our simulation... your application may or may not need this
             // The edge is positioned at the left most i.e. x = 0 and y = screenH/2 as the center. width is 1 and height = screenH
             bodyDef.position.x = 0;
             bodyDef.position.y = screenH/2/scale;
             fixDef.shape = new b2PolygonShape;
             fixDef.shape.SetAsBox(1/scale, screenH/scale);
             world.CreateBody(bodyDef).CreateFixture(fixDef);

          // Right Edge - same as left edge, positioned on the rightmost end of our canvas.
             bodyDef.position.x = screenW/scale;
             bodyDef.position.y = screenH/2/scale;
          fixDef.shape = new b2PolygonShape;
             fixDef.shape.SetAsBox(1/scale, screenH/scale);
             world.CreateBody(bodyDef).CreateFixture(fixDef);

         // Adding objects to our simulation space.
         // The difference here being, that these are dynamic objects and are affected by forces and impulses
         bodyDef.type = b2Body.b2_dynamicBody;
         /* 
         for(var i = 0; i < 10; ++i)
         {
          if(Math.random() < 0.5) {
           fixDef.shape = new b2PolygonShape;
           fixDef.shape.SetAsBox(
              Math.random() + 0.5 //half width
              ,  Math.random() + 0.5 //half height
           );
          } else {
           fixDef.shape = new b2CircleShape(
            Math.random() + 0.5 //radius
           );
          }
          bodyDef.position.x = Math.random() * screenW/scale; // put the object randomly at any position within world boundaries
          bodyDef.position.y = Math.random() * screenH/scale/4; // put object randomly in top quarter of screen at start of simulation
          world.CreateBody(bodyDef).CreateFixture(fixDef);
         }
         */

          // A callback for animation. It is widely suggested to use requestAnimFrame instead of setTimeout or setInterval for better animation performance.
         window.requestAnimFrame = (function(){
           return  window.requestAnimationFrame       ||
             window.webkitRequestAnimationFrame ||
             window.mozRequestAnimationFrame    ||
             window.oRequestAnimationFrame      ||
             window.msRequestAnimationFrame     ||
             function(/* function */ callback, /* DOMElement */ element){
            window.setTimeout(callback, 1000 / 60);
             };
         })();

         // Our update function
         function update() {
         world.Step(1 / 60, 3, 3); // timestep, velocityIterations, positionIterations. Read manual for more details

         if(drawDebug)
         {
          // A small sample of how to apply HTML5 features on the object.
          // When you press "d", this loop condition gets true
          // The circles are colored while rectangles show as they are

          // Clears the canvas context
          context.clearRect(0,0,screenW, screenH);

          // To keep showing the rectangles. It also draws the circle, but they are overwritten by the next function
          world.DrawDebugData();
          // Detects Circles & Apply colors to them
          drawCanvasObjects();
         }
         else
          // draw in the basic debug mode provided by box2d. It is very useful to see the object interactions
          world.DrawDebugData();

         // This is called after we are done with time steps to clear the forces
         world.ClearForces();

         // callback for next update
         requestAnimFrame(update);
         };

                 // Starts our update / loop
                 requestAnimFrame(update);

                 // The native function that draws the object for us to debug their physics and visualize interaction
          var debugDraw = new b2DebugDraw();
          debugDraw.SetSprite(context);
          debugDraw.SetDrawScale(scale);
          debugDraw.SetFillAlpha(0.5);
          debugDraw.SetLineThickness(1.0);
          debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit | b2DebugDraw.e_centerOfMassBit);

         world.SetDebugDraw(debugDraw);

         // Function to detect circles and color them Red
         function drawCanvasObjects()
         {
          var node = world.GetBodyList(); // returns list of all bodies attached to this world
          while(node)
          {
           var curr = node;
           node = node.GetNext();

           // Check if the identified body is of type dynamic. Remember we defined our circles as dynamic body types
           if(curr.GetType() == b2Body.b2_dynamicBody)
           {
            // Get the shape from the list of retrieved fixtures defined during initialization for each body
            var shape = curr.GetFixtureList().GetShape();

            if(shape.GetType() == circle.GetType())
            {   // If shape is circle
             var position = curr.GetPosition(); // Get the body's position in the world

             // We need to scale back the position coordinates to map them back to canvas coordinates
             var canvasY = position.y*scale;
             var canvasX = position.x*scale;

             // boundary color = white
             context.strokeStyle = "#000000";
             // fill color = red
             context.fillStyle = "#FF0000";
             context.beginPath();
             context.arc(canvasX,canvasY,shape.GetRadius()*scale,0,Math.PI*2,true);
             context.closePath();
             context.stroke();
             context.fill();
            }
           }
          }
         }
        }

        function keydown(e)
        {
         if (e.keyCode == 68) //press 'd'
         {
          drawDebug = !drawDebug;
         }
        }
        window.addEventListener("load", init, true);        // insert the listener for onload event to call our init function    
    </script>
</head>
<body style="text-align: center;background: #f2f6f8;">
<img style="clear:both;margin-bottom: 20px" src="logo.png"/>

<div></div>
<div style="display:inline-block;width:auto; margin: 0 auto; background: black; position:relative; border:5px solid black; border-radius: 10px; box-shadow: 0 5px 50px #333">
    <canvas id="canvas" width="800" height="450"></canvas>
</div>

</body>
</html>